<!-- ===== Fallout Terminal Hacking Mini-Game ===== -->
<iframe id="knech-vdt"
        allow="autoplay"
        style="position:fixed;inset:0;width:100vw;height:100vh;border:0;z-index:2147483647;"
        srcdoc='<!doctype html><html lang="en"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Terminal Hacking</title>
<style>
  /* CSS Reset */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  :root {
    --green: #41ff00;
    --dark-green: #001100;
    --bg: #000000;
    --glow: #41ff00;
  }
  
  html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    background: #000;
  }
  
  body {
    font-family: "Courier New", Courier, monospace;
    font-size: 14px;
    line-height: 1.2;
    color: var(--green);
    display: flex;
    align-items: center;
    justify-content: center;
    text-transform: uppercase;
  }
  
  .terminal {
    width: 100%;
    max-width: 800px;
    height: 100%;
    max-height: 600px;
    background: var(--bg);
    border: 2px solid #1a1a1a;
    padding: 20px;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    text-shadow: 0 0 5px var(--glow);
  }
  
  /* Scanline effect */
  .terminal::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      transparent 0%,
      transparent 50%,
      rgba(65, 255, 0, 0.03) 50%,
      rgba(65, 255, 0, 0.03) 100%
    );
    background-size: 100% 4px;
    pointer-events: none;
    z-index: 1;
  }
  
  /* Flicker effect */
  @keyframes flicker {
    0% { opacity: 0.95; }
    50% { opacity: 1; }
    100% { opacity: 0.98; }
  }
  
  .terminal > * {
    position: relative;
    z-index: 2;
    animation: flicker 0.15s infinite;
  }
  
  .header {
    margin-bottom: 10px;
  }
  
  .title {
    font-size: 16px;
    margin-bottom: 5px;
  }
  
  .attempts {
    margin: 10px 0;
    font-size: 14px;
  }
  
  .attempts-blocks {
    display: inline-block;
    margin-left: 10px;
  }
  
  .block {
    display: inline-block;
    width: 10px;
    height: 12px;
    background: var(--green);
    margin-right: 3px;
    vertical-align: middle;
  }
  
  .block.off {
    background: transparent;
    border: 1px solid var(--green);
  }
  
  #message {
    height: 20px;
    margin: 5px 0;
  }
  
  /* Main terminal display */
  .display {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    background: rgba(0, 17, 0, 0.5);
    border: 1px solid var(--green);
    padding: 10px;
    font-family: "Courier New", Courier, monospace;
    white-space: pre;
    letter-spacing: 0.05em;
  }
  
  .display::-webkit-scrollbar {
    width: 10px;
  }
  
  .display::-webkit-scrollbar-track {
    background: var(--dark-green);
  }
  
  .display::-webkit-scrollbar-thumb {
    background: var(--green);
  }
  
  /* Terminal lines */
  .line {
    margin: 2px 0;
    font-size: 14px;
    display: block;
  }
  
  .hex {
    color: var(--green);
    opacity: 0.8;
    display: inline;
  }
  
  /* Selectable elements */
  .selectable {
    cursor: pointer;
    display: inline;
    position: relative;
  }
  
  .selectable:hover {
    background: var(--green);
    color: var(--bg);
    text-shadow: none;
  }
  
  .selectable.selected {
    background: var(--green);
    color: var(--bg);
    text-shadow: none;
  }
  
  .footer {
    margin-top: 10px;
    font-size: 12px;
    opacity: 0.8;
  }
  
  /* Overlay for game end */
  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }
  
  .overlay.show {
    display: flex;
  }
  
  .overlay-text {
    font-size: 24px;
    text-align: center;
    text-shadow: 0 0 10px var(--glow);
  }
</style>
</head>
<body>
<div class="terminal">
  <div class="header">
    <div class="title">Welcome to KnechTelekom VDT 4.0</div>
    <div>ENTER PASSWORD</div>
  </div>
  
  <div class="attempts">
    <span id="attempts-text">4 ATTEMPT(S) LEFT:</span>
    <span class="attempts-blocks">
      <span class="block" data-attempt="1"></span>
      <span class="block" data-attempt="2"></span>
      <span class="block" data-attempt="3"></span>
      <span class="block" data-attempt="4"></span>
    </span>
  </div>
  
  <div id="message"></div>
  
  <div class="display" id="display"></div>
  
  <div class="footer">
    Copyright 2077 KnechTelekom Industries
  </div>
  
  <div class="overlay" id="overlay">
    <div class="overlay-text" id="overlay-text"></div>
  </div>
</div>

<script>
// Game configuration
const CONFIG = {
  wordLength: 5,
  wordCount: 15,
  attempts: 4,
  lineLength: 12,
  columns: 2
};

// Word pool
const WORD_POOL = [
  "ABOUT", "AFTER", "AGAIN", "BELOW", "COULD", "EVERY", "FIRST", "FOUND", "GREAT", "HOUSE",
  "LARGE", "LITTLE", "MIGHT", "NEVER", "OTHER", "PLACE", "RIGHT", "SMALL", "SOUND", "STILL",
  "THEIR", "THERE", "THESE", "THING", "THINK", "THREE", "UNDER", "WATER", "WHERE", "WHICH",
  "WHILE", "WORLD", "WOULD", "WRITE", "YEARS", "ABOVE", "BEGAN", "BLACK", "BRING", "BUILD",
  "CARRY", "CLEAN", "CLOSE", "DRINK", "DRIVE", "EIGHT", "FIGHT", "FORCE", "GREEN", "GROUND",
  "GUIDE", "HEART", "HEAVY", "LIGHT", "LOCAL", "MARCH", "MUSIC", "NIGHT", "NORTH", "OFTEN",
  "ORDER", "PAPER", "PARTY", "PEACE", "PIECE", "POINT", "POWER", "PRESS", "PRICE", "PRINT",
  "QUICK", "QUIET", "REACH", "RIVER", "ROUND", "SERVE", "SHAPE", "SHARP", "SHOOT", "SHORT",
  "SHOWN", "SIGHT", "SINCE", "SLEEP", "SMOKE", "SOLID", "SOUTH", "SPACE", "SPEAK", "SPEED",
  "SPEND", "SPOKE", "SPORT", "SPREAD", "SPRING", "STAND", "START", "STATE", "STICK", "STONE",
  "STOOD", "STORE", "STORY", "STUDY", "STUFF", "TEACH", "THANK", "THICK", "THIRD", "THOSE",
  "THREW", "THROW", "TOUCH", "TRADE", "TRAIN", "TRIED", "TRIES", "TRUCK", "TRUST", "TRUTH"
].filter(w => w.length === CONFIG.wordLength);

// Game state
let gameState = {
  attempts: CONFIG.attempts,
  correctWord: "",
  words: [],
  usedBrackets: new Set(),
  locked: false,
  selectedElement: null
};

// Utility functions
function random(max) {
  return Math.floor(Math.random() * max);
}

function shuffle(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = random(i + 1);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function getRandomChar() {
  const chars = "!@#$%^&*(){}[]<>,.?/|\\-+=_";
  return chars[random(chars.length)];
}

function calculateLikeness(word1, word2) {
  let likeness = 0;
  for (let i = 0; i < word1.length; i++) {
    if (word1[i] === word2[i]) likeness++;
  }
  return likeness;
}

// Generate hex address
function getHexAddress(index) {
  const base = 0xF000;
  return "0x" + (base + index * 0x0C).toString(16).toUpperCase();
}

// Audio feedback
let audioContext = null;
function playSound(frequency = 800, duration = 50) {
  try {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.value = frequency;
    oscillator.type = "square";
    gainNode.gain.value = 0.05;
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration / 1000);
  } catch (e) {
    // Silent fail if audio not supported
  }
}

// Update attempts display
function updateAttempts() {
  const blocks = document.querySelectorAll(".block");
  blocks.forEach((block, index) => {
    if (index < gameState.attempts) {
      block.classList.remove("off");
    } else {
      block.classList.add("off");
    }
  });
  
  document.getElementById("attempts-text").textContent = 
    `${gameState.attempts} ATTEMPT(S) LEFT:`;
}

// Handle word selection
function selectWord(element, word) {
  if (gameState.locked) return;
  
  playSound(1000, 30);
  
  // Remove previous selection
  if (gameState.selectedElement) {
    gameState.selectedElement.classList.remove("selected");
  }
  
  element.classList.add("selected");
  gameState.selectedElement = element;
  
  // Check if correct
  if (word === gameState.correctWord) {
    showMessage("> Password accepted.");
    gameState.locked = true;
    setTimeout(() => {
      showOverlay("ACCESS GRANTED");
      setTimeout(() => {
        // Close the terminal
        parent.postMessage({ type: "KNECH_VDT", action: "close" }, "*");
      }, 1500);
    }, 1000);
  } else {
    const likeness = calculateLikeness(word, gameState.correctWord);
    showMessage(`> Entry denied. Likeness=${likeness}`);
    
    gameState.attempts--;
    updateAttempts();
    
    if (gameState.attempts <= 0) {
      gameState.locked = true;
      setTimeout(() => {
        showOverlay("TERMINAL LOCKED");
        playSound(200, 200);
      }, 1000);
    }
  }
}

// Handle bracket selection
function selectBracket(element, bracketId) {
  if (gameState.locked || gameState.usedBrackets.has(bracketId)) return;
  
  gameState.usedBrackets.add(bracketId);
  playSound(600, 40);
  
  // Replace bracket content with dots
  const text = element.textContent;
  element.textContent = ".".repeat(text.length);
  element.style.cursor = "default";
  element.onclick = null;
  
  // 50% chance to remove dud or reset tries
  if (Math.random() < 0.5 && gameState.attempts < CONFIG.attempts) {
    gameState.attempts = CONFIG.attempts;
    updateAttempts();
    showMessage("> Tries reset.");
  } else {
    // Remove a dud (costs an attempt)
    const wrongWords = gameState.words.filter(w => w !== gameState.correctWord);
    if (wrongWords.length > 0) {
      const dudWord = wrongWords[random(wrongWords.length)];
      // Find and remove the dud from display
      const elements = document.querySelectorAll(".selectable");
      elements.forEach(el => {
        if (el.dataset.word === dudWord && el.dataset.word !== gameState.correctWord) {
          el.textContent = ".".repeat(dudWord.length);
          el.style.cursor = "default";
          el.onclick = null;
          el.classList.remove("selectable");
        }
      });
      showMessage("> Dud removed.");
      
      // Cost an attempt for dud removal
      gameState.attempts--;
      updateAttempts();
      
      if (gameState.attempts <= 0) {
        gameState.locked = true;
        setTimeout(() => {
          showOverlay("TERMINAL LOCKED");
          playSound(200, 200);
        }, 1000);
      }
    }
  }
}

// Show message
function showMessage(text) {
  const messageEl = document.getElementById("message");
  messageEl.textContent = text;
}

// Show overlay
function showOverlay(text) {
  const overlay = document.getElementById("overlay");
  const overlayText = document.getElementById("overlay-text");
  overlayText.textContent = text;
  overlay.classList.add("show");
}

// Generate game content
function generateContent() {
  const display = document.getElementById("display");
  display.innerHTML = "";
  
  // Select words
  const selectedWords = shuffle(WORD_POOL).slice(0, CONFIG.wordCount);
  gameState.words = selectedWords;
  gameState.correctWord = selectedWords[random(selectedWords.length)];
  
  // Create lines of content
  const totalLines = 20;
  const wordsPerColumn = Math.ceil(selectedWords.length / CONFIG.columns);
  let wordIndex = 0;
  
  for (let col = 0; col < CONFIG.columns; col++) {
    for (let line = 0; line < totalLines; line++) {
      const lineEl = document.createElement("div");
      lineEl.className = "line";
      
      // Add hex address
      const hexSpan = document.createElement("span");
      hexSpan.className = "hex";
      hexSpan.textContent = getHexAddress(col * totalLines + line) + " ";
      lineEl.appendChild(hexSpan);
      
      // Generate line content
      let lineContent = "";
      let charCount = 0;
      
      while (charCount < CONFIG.lineLength * 2 + CONFIG.wordLength) {
        // Randomly place words
        if (wordIndex < wordsPerColumn * (col + 1) && 
            wordIndex < selectedWords.length && 
            Math.random() < 0.3 && 
            charCount + CONFIG.wordLength <= CONFIG.lineLength * 2) {
          
          const word = selectedWords[wordIndex];
          const wordSpan = document.createElement("span");
          wordSpan.className = "selectable";
          wordSpan.textContent = word;
          wordSpan.dataset.word = word;
          wordSpan.onclick = () => selectWord(wordSpan, word);
          
          lineEl.appendChild(wordSpan);
          wordIndex++;
          charCount += word.length;
          
        } else if (Math.random() < 0.2 && charCount + 4 <= CONFIG.lineLength * 2) {
          // Add brackets
          const brackets = ["()", "[]", "{}", "<>"];
          const bracket = brackets[random(brackets.length)];
          const contentLength = 3 + random(5);
          let bracketContent = bracket[0];
          
          for (let i = 0; i < contentLength; i++) {
            bracketContent += getRandomChar();
          }
          bracketContent += bracket[1];
          
          const bracketSpan = document.createElement("span");
          bracketSpan.className = "selectable";
          bracketSpan.textContent = bracketContent;
          const bracketId = `bracket-${col}-${line}-${charCount}`;
          bracketSpan.onclick = () => selectBracket(bracketSpan, bracketId);
          
          lineEl.appendChild(bracketSpan);
          charCount += bracketContent.length;
          
        } else {
          // Add random character
          const char = getRandomChar();
          lineEl.appendChild(document.createTextNode(char));
          charCount++;
        }
        
        // Add space occasionally
        if (charCount < CONFIG.lineLength * 2 && Math.random() < 0.3) {
          lineEl.appendChild(document.createTextNode(" "));
          charCount++;
        }
      }
      
      display.appendChild(lineEl);
    }
    
    // Add column separator
    if (col < CONFIG.columns - 1) {
      const separator = document.createElement("div");
      separator.style.height = "10px";
      display.appendChild(separator);
    }
  }
}

// Initialize game
function init() {
  updateAttempts();
  generateContent();
  showMessage("");
  
  console.log("Debug - Correct word:", gameState.correctWord);
  console.log("Debug - All words:", gameState.words);
}

// Start the game
init();

// Handle iframe closing
window.addEventListener("message", function(e) {
  if (e.data && e.data.type === "KNECH_VDT" && e.data.action === "close") {
    const iframe = parent.document.getElementById("knech-vdt");
    if (iframe) iframe.remove();
  }
});
</script>
</body>
</html>'>
</iframe>

<script>
  // Remove the iframe after successful hack
  window.addEventListener('message', function(e){
    if(e && e.data && e.data.type==='KNECH_VDT' && e.data.action==='close'){
      var f=document.getElementById('knech-vdt'); 
      if(f) f.remove();
    }
  });
</script>
